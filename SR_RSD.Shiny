library(shiny)
library(readxl)
library(dplyr)
library(rstan)
library(loo)
library(ggplot2)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

ui <- fluidPage(
  titlePanel("Yokouchi et al. (2024) モデル（Stan解析）"),
  sidebarLayout(
    sidebarPanel(
      fileInput("datafile", "Excelファイルをアップロード（列名: StudentID, ItemID, TimeID, Score）"),
      actionButton("run", "Stan推論を実行")
    ),
    mainPanel(
      verbatimTextOutput("catCheck"),
      verbatimTextOutput("stanPrint"),
      plotOutput("betaPlot"),
      verbatimTextOutput("pppOut"),
      verbatimTextOutput("waiclooOut"),
      verbatimTextOutput("rmseOut"),
      verbatimTextOutput("rhatOut"),
      verbatimTextOutput("essOut")
    )
  )
)

server <- function(input, output) {
  observeEvent(input$run, {
    req(input$datafile)
    # 1. データ読み込み＆前処理
    df <- read_excel(input$datafile$datapath) %>%
      rename(
        examinee = StudentID,
        item     = ItemID,
        time     = TimeID,
        X        = Score
      ) %>%
      mutate(
        examinee = as.integer(as.factor(examinee)),
        item     = as.integer(as.factor(item)),
        time     = as.integer(as.factor(time)),
        X        = as.integer(X - min(X, na.rm = TRUE) + 1)   # ← 1始まり（Stan宣言に合わせる）
      )
    # 2. ETinter作成
    df <- df %>%
      mutate(
        ETinter = as.integer(as.factor(item * time))
      )
    # 3. Stanデータリスト
    stan_data <- list(
      N          = nrow(df),
      J          = length(unique(df$examinee)),
      T          = length(unique(df$time)),
      K          = max(df$X),  # ← これが必須！（カテゴリの最大値）
      I          = length(unique(df$ETinter)),
      ExamineeID = df$examinee,
      TimeID     = df$time,
      ETinter    = df$ETinter,
      X          = df$X
    )
    # 4. カテゴリ確認
    output$catCheck <- renderPrint({
      cat("Stanに渡すXの最小値:", min(stan_data$X), "最大値:", max(stan_data$X), "\n")
      cat("Stanに渡すK:", stan_data$K, "\n")
      print(table(stan_data$X))
    })
    # 5. Stan推論
    fit <- stan(
      file = "Yokouchi et al.stan",
      data = stan_data,
      iter = 4000, warmup = 2000, chains = 4, seed = 123,
      control = list(adapt_delta = 0.99)
    )
    # 6. パラメータ表示
    output$stanPrint <- renderPrint({
      print(fit, pars = c("theta", "beta_t", "alpha_t", "alpha_i", "beta_i", "category_est"))
    })
    sims <- extract(fit)
    # 7. β_tの事後平均プロット
    output$betaPlot <- renderPlot({
      if(!is.null(sims$beta_t)){
        beta_mean <- apply(sims$beta_t, 2, mean)
        plot(beta_mean, type = "o", xlab = "Time (t)", ylab = expression(beta[t]),
             main = expression(paste("Posterior Mean of ", beta[t])))
      }
    })
    # 8. PPP
    output$pppOut <- renderPrint({
      if(!is.null(sims$X_pre)){
        obs_score <- stan_data$X
        score_rep <- sims$X_pre
        ppp <- mean(score_rep == matrix(obs_score, nrow = nrow(score_rep), ncol = ncol(score_rep), byrow = TRUE))
        cat("PPP (Posterior Predictive p-value: 観測とレプリケート一致率) =", round(ppp, 4), "\n")
      }
    })
    # 9. WAIC・LOO
    output$waiclooOut <- renderPrint({
      if(!is.null(sims$log_lik)){
        log_lik <- sims$log_lik
        waic_result <- waic(log_lik)
        loo_result <- loo(log_lik)
        print(waic_result)
        print(loo_result)
      }
    })
    # 10. RMSE
    output$rmseOut <- renderPrint({
      if(!is.null(sims$X_pre)){
        pred_mean <- apply(sims$X_pre, 2, mean)
        obs_score <- stan_data$X
        rmse <- sqrt(mean((pred_mean - obs_score)^2))
        cat("RMSE (Root Mean Squared Error) =", round(rmse, 4), "\n")
      }
    })
    # 11. Rhat・ESS（Rhat小数点2桁で出力）
    output$rhatOut <- renderPrint({
      summary_fit <- summary(fit, pars = c("theta", "beta_t", "alpha_t", "alpha_i", "beta_i", "category_est"))$summary
      high_rhat_idx <- which(summary_fit[,"Rhat"] > 1.1)
      if(length(high_rhat_idx) > 0) {
        cat("!!! The following parameters have Rhat > 1.1 (not converged):\n")
        for(i in high_rhat_idx) {
          pname <- rownames(summary_fit)[i]
          rhat  <- summary_fit[i,"Rhat"]
          cat(sprintf("%s: Rhat = %.2f\n", pname, rhat))
        }
      } else {
        cat("All monitored parameters have Rhat <= 1.1 (converged).\n")
        for(i in seq_along(summary_fit[,"Rhat"])) {
          pname <- rownames(summary_fit)[i]
          rhat  <- summary_fit[i,"Rhat"]
          cat(sprintf("%s: Rhat = %.2f\n", pname, rhat))
        }
      }
    })
    output$essOut <- renderPrint({
      summary_fit <- summary(fit, pars = c("theta", "beta_t", "alpha_t", "alpha_i", "beta_i", "category_est"))$summary
      ess_vals <- summary_fit[,"n_eff"]
      cat("Effective Sample Size (ESS):\n")
      print(ess_vals)
      cat("Minimum ESS:", min(ess_vals, na.rm=TRUE), "\n")
      cat("Median  ESS:", median(ess_vals, na.rm=TRUE), "\n")
      cat("Maximum ESS:", max(ess_vals, na.rm=TRUE), "\n")
    })
  })
}

shinyApp(ui = ui, server = server)
